<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>最近面试遇到的算法题汇总</title>
    <url>/2020/05/27/%E6%9C%80%E8%BF%91%E9%9D%A2%E8%AF%95%E9%81%87%E5%88%B0%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今年受疫情的影响，工作不太好找。也投了不少简历，只有几家邀面试的：58同城、最右、快手、新东方，除了最右其它都是视频面试。总的来看：公司对个人能力要求还是挺高的，面试问的问题都是由浅入深，算法也是必考的。</p>
<a id="more"></a>

<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><strong>1、用递归写一个算法，计算从<code>1</code>到<code>100</code>的和。</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(value: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> value &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> number = value</span><br><span class="line">    <span class="keyword">return</span> value + sum(value: number - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写完算法之后又围绕着问了几个问题，都是算法基础：</p>
<ul>
<li><p>算法的时间复杂度是多少?</p>
<p>$O(n)$</p>
</li>
<li><p>递归会有什么缺点？</p>
<p>数据规模过大时，容易造成栈溢出。 每一轮递归都要分配栈空间，做栈帧平衡。</p>
</li>
<li><p>不用递归能否实现，复杂度能否降到 $O(1)$？</p>
<p>可以。使用等差数列通项公式：$n*(n+1)/2$。具体实现如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n * (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>2、给定一个<code>Int</code>型数组，用里面的元素组成一个最大数，因为数字可能非常大，用字符串输出。</strong></p>
<p>分析：实际上就是一个排序而已，只不过它是按高位优先级更高的原则，这一点跟字符串的比较保持一致，如果再加一些<code>Swift</code>的高阶函数，很容易写出来。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">largestNumber</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">sort</span> = nums.<span class="built_in">map</span> &#123;<span class="string">"\($0)"</span>&#125;.sorted &#123;(lStr, rStr) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> lStr + rStr &gt; rStr + lStr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">sort</span>.joined()</span><br><span class="line">    <span class="keyword">if</span> result.<span class="keyword">prefix</span>(<span class="number">1</span>) == <span class="string">"0"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>3.给定一个<code>Int</code>型数组，找出第一个只出现一次的数字。</strong></p>
<p>分析：可以通过遍历把数组元素存入到字典中，以数组元素的<code>value</code>为字典的<code>key</code>，数组元素的<code>index</code>为字典的<code>value</code>。在遍历过程中，如果遇到重复的<code>key</code>，则更改其<code>value</code>为一个定值（为避免出错，这里设这个定值为数组元素的<code>count</code>）。那么遍历完成后，字典中所有<code>value=count</code>的<code>key</code>即为数组中存在重复的数字，而其它的<code>key</code>（即数组中不存在重复的数字）的<code>value</code>肯定是小于<code>count</code>的，这时候我们再对字典的 <code>values</code>进行升序排序，设排序后的数组为<code>sort</code>，如果<code>sort</code>中第一个元素的值等于<code>count</code>，说明元素组中不存在只出现一次的数字；否则，<code>sort</code>中的第一个元素即为第一个只出现一次的数字的<code>index</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findFirstNumberOnlyAppearsOnce</span><span class="params">(<span class="keyword">in</span> nums: [Int])</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dict = [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">count</span> = nums.<span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (index, number) <span class="keyword">in</span> nums.enumerated() &#123;</span><br><span class="line">         <span class="keyword">if</span> !dict.keys.<span class="built_in">contains</span>(number) &#123;</span><br><span class="line">             dict[number] = index</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             dict[number] = <span class="built_in">count</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">if</span> <span class="keyword">let</span> result = dict.values.sorted().first &#123;</span><br><span class="line">         <span class="keyword">if</span> result == <span class="built_in">count</span> &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> nums[result]</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<center><求职路艰辛，持续更新中></center>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表反转</title>
    <url>/2020/05/27/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="单链表反转"><a href="#单链表反转" class="headerlink" title="单链表反转"></a>单链表反转</h1><p>单链表的数据结构如下图所示：</p>
<p><img src="https://pic.downk.cc/item/5ece1b76c2a9a83be57a4624.png" alt="image.png"></p>
<p>假如有一个单链表是：1-&gt;2-&gt;3-&gt;4-&gt;NULL，那么经过反转后就变为：4-&gt;3-&gt;2-&gt;1-&gt;NULL。</p>
<a id="more"></a>

<h1 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h1><ul>
<li><p>定义单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造单链表</p>
<p>构造单链表的思想就是：创建一个节点，然后判断是否有头结点，如果有，就将当前节点的<code>next</code>指向新创建的节点，然后将当前节点向后移动；如果没有，就将头结点和当前节点都赋值为新创建的节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">constructList</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义头部节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 记录当前结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">cur</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">        node-&gt;data = i;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 头结点为空，当前节点为头结点</span></span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前节点的 next 为新节点</span></span><br><span class="line">            cur-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置当前节点</span></span><br><span class="line">        cur = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链表反转（头插法）</p>
<p>头插法需要我们定义一个新的头结点作为新的链表，然后利用头插法，将原来的链表的每一个节点取出来，然后去新的链表里面做头插法，这样就可以反转了，这里需要一个新的头结点，和遍历原来链表的一个<code>p</code>指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">reverseList</span><span class="params">(struct Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个遍历指针，并初始化为头结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// 反转后的头结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newH</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录下一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> = <span class="title">p</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        <span class="comment">// 当前节点的 next 指向新链表头部</span></span><br><span class="line">        p-&gt;next = newH;</span><br><span class="line">        <span class="comment">// 更改新链表头部为当前节点</span></span><br><span class="line">        newH = p;</span><br><span class="line">        <span class="comment">// 移动 p 指针</span></span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印链表数据</p>
<p>最后，我们打印下链表数据，看下效果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(struct Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> = <span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"node is %d \n"</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/2020/05/27/About-Me/</url>
    <content><![CDATA[<p>坐标：北京</p>
<p>GitHub：<a href="https://github.com/bestDew" target="_blank" rel="noopener">bestDew</a></p>
<p>邮箱：<a href="mailto:a_pple0429@163.com">a_pple0429@163.com</a></p>
<p><img src="https://pic.downk.cc/item/5ece03d2c2a9a83be5594e21.png" alt="avatar.png"></p>
<blockquote>
<p>一名文艺的 iOS 开发者~</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
