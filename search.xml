<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2020/05/27/About-Me/</url>
    <content><![CDATA[<p>坐标：北京</p>
<p>GitHub：<a href="https://github.com/bestDew" target="_blank" rel="noopener">bestDew</a></p>
<p>邮箱：<a href="mailto:a_pple0429@163.com">a_pple0429@163.com</a></p>
<p><img src="https://pic.downk.cc/item/5ece03d2c2a9a83be5594e21.png" alt="avatar.png"></p>
<blockquote>
<p>一名文艺的 iOS 开发者~</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表反转</title>
    <url>/2020/05/27/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<blockquote>
<p>最近在找工作，面试新东方的时候被问到这个问题，这里总结下，免得以后又忘记:joy:。</p>
</blockquote>
<h1 id="单链表反转"><a href="#单链表反转" class="headerlink" title="单链表反转"></a>单链表反转</h1><p>单链表的数据结构如下图所示：</p>
<p><img src="https://pic.downk.cc/item/5ece1b76c2a9a83be57a4624.png" alt="image.png"></p>
<p>假如有一个单链表是：1-&gt;2-&gt;3-&gt;4-&gt;NULL，那么经过反转后就变为：4-&gt;3-&gt;2-&gt;1-&gt;NULL。</p>
<h1 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a>具体代码实现</h1><ul>
<li><p>定义单链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造单链表</p>
<p>构造单链表的思想就是：创建一个节点，然后判断是否有头结点，如果有，就将当前节点的<code>next</code>指向新创建的节点，然后将当前节点向后移动；如果没有，就将头结点和当前节点都赋值为新创建的节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">constructList</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义头部节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">head</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 记录当前结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">cur</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">node</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">Node</span>));</span></span><br><span class="line">        node-&gt;data = i;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 头结点为空，当前节点为头结点</span></span><br><span class="line">            head = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前节点的 next 为新节点</span></span><br><span class="line">            cur-&gt;next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置当前节点</span></span><br><span class="line">        cur = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链表反转（头插法）</p>
<p>头插法需要我们定义一个新的头结点作为新的链表，然后利用头插法，将原来的链表的每一个节点取出来，然后去新的链表里面做头插法，这样就可以反转了，这里需要一个新的头结点，和遍历原来链表的一个<code>p</code>指针。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct Node* <span class="title">reverseList</span><span class="params">(struct Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个遍历指针，并初始化为头结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// 反转后的头结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">newH</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录下一个节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> = <span class="title">p</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        <span class="comment">// 当前节点的 next 指向新链表头部</span></span><br><span class="line">        p-&gt;next = newH;</span><br><span class="line">        <span class="comment">// 更改新链表头部为当前节点</span></span><br><span class="line">        newH = p;</span><br><span class="line">        <span class="comment">// 移动 p 指针</span></span><br><span class="line">        p = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印链表数据</p>
<p>最后，我们打印下链表数据，看下效果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(struct Node *node)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">temp</span> = <span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"node is %d \n"</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
